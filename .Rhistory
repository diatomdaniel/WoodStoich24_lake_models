mod2 <- add_criterion(mod2, criterion = c("loo", "bayes_R2"))
#mod3
mod3 <- brm(zscore_lake_area ~ zscore_gwl + (1 | Lake ),
sigma ~ year + Lake, data = merged_data, family = student(), prior = priors,
chains = 4, iter = 2000, control = list(adapt_delta = 0.95),
file = "C://Users/DanielGschwentner/Desktop/CLNWR mapping lake area 2022/stan_models/mod3")
summary(mod3)
pp_check(mod3)
bayesplot::mcmc_trace(mod3)
bayes_R2(mod3)
mod3 <- add_criterion(mod3, criterion = c("loo", "bayes_R2"))
# compare models
mod.comp <- loo_compare(mod1, mod2, mod3)
print(mod.comp, simplify = F)
round(model_weights(mod1, mod2, mod3, weights = "loo"),5)
###############################################################################
### Create figure of explanatory variables
# legend object.
yr.lg <- c(
"2016" = "grey70",
"2017" = "#ece2f0",
"2018" = "#d0d1e6",
"2019" = "#a6bddb",
"2020" = "#67a9cf",
"2021" = "#3690c0",
"2022" = "#02818a",
"2023" = "#016c59",
"2024" = "#014636"
)
(fig.ave.temp <- clim %>%
ggplot(aes(month, ave_temp, group = year, col = factor(year))) +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "Mean monthly temp. C", col = NULL))
(fig.max.temp <- clim %>%
ggplot(aes(month, max_temp, group = year, col = factor(year))) +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "Mean max. monthly temp. C", col = NULL))
(fig.nrdays90F <- clim %>%
ggplot(aes(month, nr_days_above90F, group = year, col = factor(year))) +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "# Days above 90F", col = NULL))
(fig.total.precip <- clim %>%
ggplot(aes(month, sum_precip, group = year, col = factor(year))) +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "Total precip. mm", col = NULL))
(fig.cumsum.precip <- clim %>%
ggplot(aes(month, cumsum_precip, group = year, col = factor(year))) +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "Cumulative total precip. mm", col = NULL))
(fig.gwl <- gwl %>%
ggplot(aes(month, gwl_bl_surface_ft, group = year, col = factor(year))) +
geom_hline(yintercept = 0, lty = "dashed") +
geom_path(lwd = 0.75) +
scale_x_continuous(breaks = c(1, 3, 6, 9, 12)) +
scale_color_manual(values = yr.lg) +
labs(x = NULL, y = "Groundwater level below surface ft.", col = NULL))
## arrange into one figure
plt.list <- list(fig.ave.temp, fig.max.temp, fig.nrdays90F,
fig.total.precip, fig.cumsum.precip, fig.gwl)
fig.drivers <- ggpubr::ggarrange(plotlist = plt.list,
nrow = 2, ncol = 3, labels = letters[1:6],
align = "hv", common.legend = T, legend = "bottom")
fig.drivers
save_plot("C://Users/DanielGschwentner/Desktop/CLNWR mapping lake area 2022/lake_area_predictors.png",
fig.drivers, base_width = 12, base_height = 7)
summary(mod1)
summary(mod2)
summary(mod3)
# set wd
rm(list = ls())
setwd("C:/Users/DanielGschwentner/Documents/GitHub/WoodStoich24_lake_models")
###############################################################################
# Setup
# load Corman data (needs to be run first!
source("clean_corman.R")
# to df for data input
in.grid <- as.data.frame(corman2)
#load packages
pck <- c("deSolve", "tidyverse", "cowplot", "ggthemes","ggpubr")
lapply(pck, require, character.only = T)
theme_set(theme_pubr() + theme(legend.position = "bottom"))
# Load algae parameters
source("algae_param_vctrs.R")
# Load models
# static model with fixed stoichiometry
source("models/static_liebig_zmix.R") # model 1 in Carly's framework
# Droop model
source("models/dynamic_liebig_zmix.R")
# set timesteps
times <- 1:2000 # for troubleshooting, initial runs
################################################################################
### base predictions w. median values
# static model
(start <- Sys.time())
corman.static <-  lapply(list(static.algae, static.diatoms, static.greens, static.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"])
run <- ode(y, times, parms = params, func = static.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.static.average <- as_data_frame(do.call(rbind, corman.static[[1]]))
corman.static.diatoms <- as_data_frame(do.call(rbind, corman.static[[2]]))
corman.static.greens <- as_data_frame(do.call(rbind, corman.static[[3]]))
corman.static.cyanos <- as_data_frame(do.call(rbind, corman.static[[4]]))
# create summary data frame
static.out <- corman2
static.out$average <- corman.static.average$GPP
static.out$diatoms <- corman.static.diatoms$GPP
static.out$greens <- corman.static.greens$GPP
static.out$cyanos <- corman.static.cyanos$GPP
static.out$model <- "static"
# dynamic model
(start <- Sys.time())
corman.dynamic <-  lapply(list(dynamic.algae, dynamic.diatoms, dynamic.greens, dynamic.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"],
"QP1" = 0.015, "QN1" = 0.1)
run <- ode(y, times, parms = params, func = dynamic.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.dynamic.average <- as_data_frame(do.call(rbind, corman.dynamic[[1]]))
corman.dynamic.diatoms <- as_data_frame(do.call(rbind, corman.dynamic[[2]]))
corman.dynamic.greens <- as_data_frame(do.call(rbind, corman.dynamic[[3]]))
corman.dynamic.cyanos <- as_data_frame(do.call(rbind, corman.dynamic[[4]]))
# create summary data frame
dynamic.out <- corman2
dynamic.out$average <- corman.dynamic.average$GPP
dynamic.out$diatoms <- corman.dynamic.diatoms$GPP
dynamic.out$greens <- corman.dynamic.greens$GPP
dynamic.out$cyanos <- corman.dynamic.cyanos$GPP
dynamic.out$model <- "dynamic"
# merge and unit conversions, GPP standardization
base.predictions.corman <- bind_rows(static.out, dynamic.out)
base.predictions.corman$model <- factor(base.predictions.corman$model, levels = c("static", "dynamic"))
# wide to long
base.predictions.corman <- base.predictions.corman %>%
gather("species", "est_GPP", -Lake, -c(1:16), -model) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos"))) %>%
group_by(model, Lake) %>%
mutate(zscore_gpp = (est_GPP - mean(est_GPP))/sd(est_GPP)) %>%
ungroup()
View(base.predictions.corman)
# wide to long
base.predictions.corman <- base.predictions.corman %>%
gather("species", "est_GPP", -Lake, -c(1:16), -model) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos"))) %>%
group_by(model, Lake) %>%
mutate(zscore_gpp = (est_GPP - mean(est_GPP))/sd(est_GPP)) %>%
ungroup() %>%
mutate(zscore_obs_gpp = (GPP - mean(GPP))/sd(GPP))
base.predictions.corman <- bind_rows(static.out, dynamic.out)
base.predictions.corman$model <- factor(base.predictions.corman$model, levels = c("static", "dynamic"))
# wide to long
base.predictions.corman <- base.predictions.corman %>%
gather("species", "est_GPP", -Lake, -c(1:16), -model) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos"))) %>%
group_by(model, Lake) %>%
mutate(zscore_gpp = (est_GPP - mean(est_GPP))/sd(est_GPP)) %>%
ungroup() %>%
mutate(zscore_obs_gpp = (GPP - mean(GPP))/sd(GPP))
View(base.predictions.corman)
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.3, col = "black"))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.6, col = "black"))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.1, col = "black"))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.1, col = "black") +
geom_density(aes(zscore_gpp, fill = species), fill = "grey20", alpha = 0.1, col = "black") +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.1, col = "black") +
geom_density(aes(zscore_gpp, fill = species), alpha = 0.1, col = "black") +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", alpha = 0.1, col = "black") +
geom_density(aes(zscore_gpp, fill = species),  col = "black") +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black") +
geom_density(aes(zscore_gpp, fill = species),  col = "black") +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp, fill = species),  col = "black") +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black") +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp, fill = species),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~.))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(spcies~model))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(species~model))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(
test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species) +
labs(x = "z-score observed and measured GPP", y = "Density"))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species, sclaes = "free_y") +
labs(x = "z-score observed and measured GPP", y = "Density"))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(test <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species, scales = "free_y") +
labs(x = "z-score observed and measured GPP", y = "Density"))
# add regression coefs (manually)
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "average", ]))
### phytoSTOICH
### Seston C:N:P validation
### DG, September 2024
# set wd
rm(list = ls())
setwd("C:/Users/DanielGschwentner/Documents/GitHub/WoodStoich24_lake_models")
###############################################################################
# Setup
#load packages
pck <- c("deSolve", "tidyverse", "cowplot", "ggthemes","ggpubr")
lapply(pck, require, character.only = T)
theme_set(theme_pubr() + theme(legend.position = "bottom"))
# Load algae parameters
source("algae_param_vctrs.R")
# Load models
# static model with fixed stoichiometry
source("models/static_liebig_zmix.R") # model 1 in Carly's framework
# Droop model
source("models/dynamic_liebig_zmix.R")
# set timesteps
times <- 1:2000 # for troubleshooting, initial runs
# load data
NEON_Flat <- read_csv("data4input/NEON_Flathead_forcing.csv")
NEON_Flat <- as.data.frame(NEON_Flat)
################################################################################
### base predictions w. median values
# dynamic model
(start <- Sys.time())
NEON.dynamic <-  lapply(list(dynamic.algae, dynamic.diatoms, dynamic.greens, dynamic.cyanos), function(x) {
params <- x
lapply(1:nrow(NEON_Flat), function(i) {
params["Pin"] = NEON_Flat[i, "Pin_mgm-3"]
params["Nin"] = NEON_Flat[i, "Nin_mgm-3"]
params["DOC"] = NEON_Flat[i, "DOC_mgL-1"]
params["z"] = NEON_Flat[i, "mean depth_m"]
params["SA"] = NEON_Flat[i, "SA_km2"]
params["HRT"] = NEON_Flat[i, "HRT_years_mixedlayer"]
y <- c("A1" = 100, "P" =NEON_Flat[i, "Pin_mgm-3"], "N" = NEON_Flat[i, "Nin_mgm-3"],
"QP1" = 0.015, "QN1" = 0.1)
run <- ode(y, times, parms = params, func = dynamic.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
NEON.dynamic.average <- as_data_frame(do.call(rbind, NEON.dynamic[[1]]))
NEON.dynamic.diatoms <- as_data_frame(do.call(rbind, NEON.dynamic[[2]]))
NEON.dynamic.greens <- as_data_frame(do.call(rbind, NEON.dynamic[[3]]))
NEON.dynamic.cyanos <- as_data_frame(do.call(rbind, NEON.dynamic[[4]]))
################################################################################
### bind everything together and clean data
NEON.CNP <- bind_rows(NEON.dynamic.average,
NEON.dynamic.diatoms,
NEON.dynamic.greens,
NEON.dynamic.cyanos)
# add-in information
NEON.CNP$Lake <- rep(NEON_Flat$lake, 4)
NEON.CNP$species <- rep(c("average", "diatoms", "greens", "cyanos"), each = nrow(NEON_Flat))
# some mutating and cleaning
NEON.CNP <- NEON.CNP %>%
mutate(CN_mass_model = 1/QN1,
CP_mass_model = 1/QP1,
NP_mass_model = QN1/QP1) %>%
rename(P_mod_ugL = P, N_mod_ugL = N) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos")))
View(NEON.CNP)
# add-in information
NEON.CNP$Lake <- rep(NEON_Flat$lake, 4)
NEON.CNP$species <- rep(c("average", "diatoms", "greens", "cyanos"), each = nrow(NEON_Flat))
View(NEON.CNP)
# save for Helena ternary plot
write_csv(NEON.CNP, "figures/NEON_Flathead_model_seston_estimates.csv")
### phytoSTOICH
### GPP validation
### DG, September 2024
# set wd
rm(list = ls())
setwd("C:/Users/DanielGschwentner/Documents/GitHub/WoodStoich24_lake_models")
###############################################################################
# Setup
# load Corman data (needs to be run first!
source("clean_corman.R")
# to df for data input
in.grid <- as.data.frame(corman2)
#load packages
pck <- c("deSolve", "tidyverse", "cowplot", "ggthemes","ggpubr")
lapply(pck, require, character.only = T)
theme_set(theme_pubr() + theme(legend.position = "bottom"))
# Load algae parameters
source("algae_param_vctrs.R")
# Load models
# static model with fixed stoichiometry
source("models/static_liebig_zmix.R") # model 1 in Carly's framework
# Droop model
source("models/dynamic_liebig_zmix.R")
# set timesteps
times <- 1:2000 # for troubleshooting, initial runs
################################################################################
### base predictions w. median values
# static model
(start <- Sys.time())
corman.static <-  lapply(list(static.algae, static.diatoms, static.greens, static.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"])
run <- ode(y, times, parms = params, func = static.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.static.average <- as_data_frame(do.call(rbind, corman.static[[1]]))
corman.static.diatoms <- as_data_frame(do.call(rbind, corman.static[[2]]))
corman.static.greens <- as_data_frame(do.call(rbind, corman.static[[3]]))
corman.static.cyanos <- as_data_frame(do.call(rbind, corman.static[[4]]))
# create summary data frame
static.out <- corman2
static.out$average <- corman.static.average$GPP
static.out$diatoms <- corman.static.diatoms$GPP
static.out$greens <- corman.static.greens$GPP
static.out$cyanos <- corman.static.cyanos$GPP
static.out$model <- "static"
# dynamic model
(start <- Sys.time())
corman.dynamic <-  lapply(list(dynamic.algae, dynamic.diatoms, dynamic.greens, dynamic.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"],
"QP1" = 0.015, "QN1" = 0.1)
run <- ode(y, times, parms = params, func = dynamic.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.dynamic.average <- as_data_frame(do.call(rbind, corman.dynamic[[1]]))
corman.dynamic.diatoms <- as_data_frame(do.call(rbind, corman.dynamic[[2]]))
corman.dynamic.greens <- as_data_frame(do.call(rbind, corman.dynamic[[3]]))
corman.dynamic.cyanos <- as_data_frame(do.call(rbind, corman.dynamic[[4]]))
# create summary data frame
dynamic.out <- corman2
dynamic.out$average <- corman.dynamic.average$GPP
dynamic.out$diatoms <- corman.dynamic.diatoms$GPP
dynamic.out$greens <- corman.dynamic.greens$GPP
dynamic.out$cyanos <- corman.dynamic.cyanos$GPP
dynamic.out$model <- "dynamic"
# merge and unit conversions, GPP standardization
base.predictions.corman <- bind_rows(static.out, dynamic.out)
base.predictions.corman$model <- factor(base.predictions.corman$model, levels = c("static", "dynamic"))
# wide to long
base.predictions.corman <- base.predictions.corman %>%
gather("species", "est_GPP", -Lake, -c(1:16), -model) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos"))) %>%
group_by(model, Lake) %>%
mutate(zscore_gpp = (est_GPP - mean(est_GPP))/sd(est_GPP)) %>%
ungroup() %>%
mutate(zscore_obs_gpp = (GPP - mean(GPP))/sd(GPP))
################################################################################
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(gpp.density <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species, scales = "free_y") +
labs(x = "z-score observed and measured GPP", y = "Density"))
# add regression coefs (manually)
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "average", ]))
# load data
NEON_Flat <- read_csv("data4input/NEON_Flathead_forcing.csv")
View(NEON_Flat)
(gpp.density <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species, scales = "free_y") +
labs(x = "z-score observed and measured GPP", y = "Density"))
# add regression coefs (manually)
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "average", ]))
NEON_Flat$`Nin_mgm-3`/NEON_Flat$`Pin_mgm-3`
mean(NEON_Flat$`Nin_mgm-3`/NEON_Flat$`Pin_mgm-3`)
median(NEON_Flat$`Nin_mgm-3`/NEON_Flat$`Pin_mgm-3`)
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "average", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "diatoms", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "greens", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "static" & base.predictions.corman$species == "cyanos", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "dynamic" & base.predictions.corman$species == "average", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "dynamic" & base.predictions.corman$species == "diatoms", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "dynamic" & base.predictions.corman$species == "greens", ]))
summary(lm(zscore_obs_gpp ~ zscore_gpp, data = base.predictions.corman[base.predictions.corman$model == "dynamic" & base.predictions.corman$species == "cyanos", ]))
### Decided to visualize density distributions of z-scores for models and measured GPP; better for pattern comparison?
(gpp.density <- base.predictions.corman %>%
ggplot() +
geom_density(aes(zscore_gpp),  col = "black", alpha = 0.3) +
geom_density(aes(zscore_obs_gpp), fill = "grey20", col = "black", alpha = 0.3) +
facet_grid(model~species, scales = "free_y") +
labs(x = "z-score observed and measured GPP", y = "Density"))
save_plot("figures/gpp_validation_densities.png", gpp.density, base_height = 6, base_width = 8)
