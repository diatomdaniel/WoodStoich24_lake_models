lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
# merge scenarios
sim.mich <- rbind(sim.mich.1, sim.mich.2)
colnames(sim.mich) <- c("time", "A1.sim", "P.sim", "N.sim", "GPP.sim",
"Pin", "Nin", "param", "scenario")
sim.mich <- merge(sim.mich, baselines.mich,
by = c("Pin", "Nin", "time"))
# calculate percent change relative to baseline
sim.mich$change2baseline <- sim.mich$GPP.sim * 100/sim.mich$GPP - 100
# determine min/max change
# note that this code doesn't tell us about direction of change, only the magnitude
sim.mich.metrics <- sim.mich %>%
mutate(change2baseline2 =  abs(change2baseline)) %>%
pivot_wider(id_cols = c(Pin, Nin, scenario),
names_from = param,
values_from = change2baseline2)
colnames(sim.mich.metrics)
sim.mich.metrics[,-c(1, 2, 3)] <- apply(sim.mich.metrics[,-c(1, 2, 3)], 2, abs)
# drop first two rows as they contain NANs
sim.mich.metrics <- sim.mich.metrics[-c(1, 2),]
sim.mich.metrics$max.change <- colnames(sim.mich.metrics[-c(1,2,3)])[apply(sim.mich.metrics[,-c(1,2,3)], 1, which.max)]
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
# timesteps
times <- 1:2000
# loads
# Olson&Jones use 20 to 500 for P. Use similar values
# for TP: TP from 2018-219 NLA stream assement ranges from 2 to 950 ugL with 25th and 7th percentiles of 23 and 133 ugL. DG, August 2024
# for TN: TN from 2018-2019 NLA Stream Assessment ranges from 22 to 22,000 ugL with 25th and 75th percentiles of 300 and 1,4000 ug L; DG, August 2024
loads <- expand.grid(Pin = seq(20, 500, 50 ) ,
Nin = seq(100,15000,500))
# for trouble-shooting use a smaller grid
loads <- expand.grid(Pin = c(20, 50, 100, 500) ,
Nin = c(100, 500, 1000, 1500))
baselines.mich <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100,
"P" = loads[i, "Pin"],
"N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
baselines.mich <- do.call(rbind, baselines.mich)
baselines.mich <- as_data_frame(baselines.mich)
baselines.mich$Pin <- loads$Pin
baselines.mich$Nin <- loads$Nin
# for troubleshooting
times <- 1:1000
baselines.mich <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100,
"P" = loads[i, "Pin"],
"N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
baselines.mich <- do.call(rbind, baselines.mich)
baselines.mich <- as_data_frame(baselines.mich)
baselines.mich$Pin <- loads$Pin
baselines.mich$Nin <- loads$Nin
# iterate over parameters
sim.mich.1 <- lapply(list("KP1","QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 1.1
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
# add info on the parameter that was varied
sim.1$param <- f
return(sim.1)
})
sim.mich.1 <- do.call(rbind, sim.mich.1)
sim.mich.1$scenario <- "+10%"
# iterate over parameters
sim.mich.2 <- lapply(list("KP1", "QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 0.9
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
sim.1$param <- f
return(sim.1)
})
sim.mich.2 <- do.call(rbind, sim.mich.2)
sim.mich.2$scenario <- "-10%"
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
View(loads)
# merge scenarios
sim.mich <- rbind(sim.mich.1, sim.mich.2)
colnames(sim.mich) <- c("time", "A1.sim", "P.sim", "N.sim", "GPP.sim",
"Pin", "Nin", "param", "scenario")
sim.mich <- merge(sim.mich, baselines.mich,
by = c("Pin", "Nin", "time"))
# calculate percent change relative to baseline
sim.mich$change2baseline <- sim.mich$GPP.sim * 100/sim.mich$GPP - 100
# determine min/max change
# note that this code doesn't tell us about direction of change, only the magnitude
sim.mich.metrics <- sim.mich %>%
mutate(change2baseline2 =  abs(change2baseline)) %>%
pivot_wider(id_cols = c(Pin, Nin, scenario),
names_from = param,
values_from = change2baseline2)
colnames(sim.mich.metrics)
sim.mich.metrics[,-c(1, 2, 3)] <- apply(sim.mich.metrics[,-c(1, 2, 3)], 2, abs)
# drop first two rows as they contain NANs
sim.mich.metrics <- sim.mich.metrics[-c(1, 2),]
sim.mich.metrics$max.change <- colnames(sim.mich.metrics[-c(1,2,3)])[apply(sim.mich.metrics[,-c(1,2,3)], 1, which.max)]
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
# for trouble-shooting use a smaller grid
loads <- expand.grid(Pin = c(20, 50, 100, 500) ,
Nin = c(500, 1000, 5000, 10000))
baselines.mich <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100,
"P" = loads[i, "Pin"],
"N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
baselines.mich <- do.call(rbind, baselines.mich)
baselines.mich <- as_data_frame(baselines.mich)
baselines.mich$Pin <- loads$Pin
baselines.mich$Nin <- loads$Nin
# iterate over parameters
sim.mich.1 <- lapply(list("KP1","QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 1.1
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
# add info on the parameter that was varied
sim.1$param <- f
return(sim.1)
})
sim.mich.1 <- do.call(rbind, sim.mich.1)
sim.mich.1$scenario <- "+10%"
# iterate over parameters
sim.mich.2 <- lapply(list("KP1", "QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 0.9
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
sim.1$param <- f
return(sim.1)
})
sim.mich.2 <- do.call(rbind, sim.mich.2)
sim.mich.2$scenario <- "-10%"
# merge scenarios
sim.mich <- rbind(sim.mich.1, sim.mich.2)
colnames(sim.mich) <- c("time", "A1.sim", "P.sim", "N.sim", "GPP.sim",
"Pin", "Nin", "param", "scenario")
sim.mich <- merge(sim.mich, baselines.mich,
by = c("Pin", "Nin", "time"))
# calculate percent change relative to baseline
sim.mich$change2baseline <- sim.mich$GPP.sim * 100/sim.mich$GPP - 100
# determine min/max change
# note that this code doesn't tell us about direction of change, only the magnitude
sim.mich.metrics <- sim.mich %>%
mutate(change2baseline2 =  abs(change2baseline)) %>%
pivot_wider(id_cols = c(Pin, Nin, scenario),
names_from = param,
values_from = change2baseline2)
colnames(sim.mich.metrics)
sim.mich.metrics[,-c(1, 2, 3)] <- apply(sim.mich.metrics[,-c(1, 2, 3)], 2, abs)
# drop first two rows as they contain NANs
sim.mich.metrics <- sim.mich.metrics[-c(1, 2),]
sim.mich.metrics$max.change <- colnames(sim.mich.metrics[-c(1,2,3)])[apply(sim.mich.metrics[,-c(1,2,3)], 1, which.max)]
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
#geom_raster() +
geom_tile() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
# for trouble-shooting use a smaller grid
loads <- expand.grid(Pin = c(20, 50, 100, 500) ,
Nin = c(500, 1000, 2000, 5000))
baselines.mich <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100,
"P" = loads[i, "Pin"],
"N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
baselines.mich <- do.call(rbind, baselines.mich)
baselines.mich <- as_data_frame(baselines.mich)
baselines.mich$Pin <- loads$Pin
baselines.mich$Nin <- loads$Nin
# iterate over parameters
sim.mich.1 <- lapply(list("KP1","QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 1.1
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
# add info on the parameter that was varied
sim.1$param <- f
return(sim.1)
})
sim.mich.1 <- do.call(rbind, sim.mich.1)
sim.mich.1$scenario <- "+10%"
# iterate over parameters
sim.mich.2 <- lapply(list("KP1", "QP1", "KN1", "QN1"), function(f) {
params.mich[f] <- params.mich[f] * 0.9
# iterate over loads
sim.1 <- lapply(1:nrow(loads), function(i) {
params.mich["Pin"] = loads[i, "Pin"]
params.mich["Nin"] = loads[i, "Nin"]
y <- c("A1" = 100, "P" = loads[i, "Pin"], "N" = loads[i, "Nin"])
run <- ode(y, times, parms = params.mich, func = mich.single)
return(run[max(times),])
})
# add meta-data
sim.1 <- do.call(rbind, sim.1)
sim.1 <- as_data_frame(sim.1)
sim.1$Pin <- loads$Pin
sim.1$Nin <- loads$Nin
sim.1$param <- f
return(sim.1)
})
sim.mich.2 <- do.call(rbind, sim.mich.2)
sim.mich.2$scenario <- "-10%"
# merge scenarios
sim.mich <- rbind(sim.mich.1, sim.mich.2)
colnames(sim.mich) <- c("time", "A1.sim", "P.sim", "N.sim", "GPP.sim",
"Pin", "Nin", "param", "scenario")
sim.mich <- merge(sim.mich, baselines.mich,
by = c("Pin", "Nin", "time"))
# calculate percent change relative to baseline
sim.mich$change2baseline <- sim.mich$GPP.sim * 100/sim.mich$GPP - 100
# determine min/max change
# note that this code doesn't tell us about direction of change, only the magnitude
sim.mich.metrics <- sim.mich %>%
mutate(change2baseline2 =  abs(change2baseline)) %>%
pivot_wider(id_cols = c(Pin, Nin, scenario),
names_from = param,
values_from = change2baseline2)
colnames(sim.mich.metrics)
sim.mich.metrics[,-c(1, 2, 3)] <- apply(sim.mich.metrics[,-c(1, 2, 3)], 2, abs)
# drop first two rows as they contain NANs
sim.mich.metrics <- sim.mich.metrics[-c(1, 2),]
sim.mich.metrics$max.change <- colnames(sim.mich.metrics[-c(1,2,3)])[apply(sim.mich.metrics[,-c(1,2,3)], 1, which.max)]
mich.menten.1 <- sim.mich %>%
#filter(Pin > 20, Nin > 20) %>%
ggplot(aes(Pin, Nin, fill = change2baseline)) +
geom_raster() +
geom_abline(intercept = 0, slope = (16 * 14.007)/30.974,
lwd = 1, lty = "dashed", col = "white") +
facet_grid(scenario ~ param) +
#scale_fill_viridis_c(option = "H") +
# scale_fill_viridis_b(breaks = c(
#   -100, -50, 0, 10, 50, 100, 500, 1000
# ), option = "H") +
scale_fill_viridis_c() +
labs(x = "P in ppm", y = "N in ppm", fill = "% change")
mich.menten.1
expand.grid(KP1 = c(1, 5, 10, 15), KN1 = c(10, 15, 20, 30, 50), QP1 = c(0.01, 0.05, 0.1, 0.2), QPN1 = c(0.01, 0.05, 0.1, 02), umax = c(0.1, 0.25, 0.5, 0.75, 1, 1.5))
x <- expand.grid(KP1 = c(1, 5, 10, 15), KN1 = c(10, 15, 20, 30, 50), QP1 = c(0.01, 0.05, 0.1, 0.2), QPN1 = c(0.01, 0.05, 0.1, 02), umax = c(0.1, 0.25, 0.5, 0.75, 1, 1.5))
nrow(x)
nrow(x) * 91
library(tidyverse)
load("C:/Users/DanielGschwentner/Documents/GitHub/WoodStoich24_lake_models/sensitivity_analysis.Rdata")
### phytoSTOICH
### GPP validation
### DG, September 2024
# set wd
rm(list = ls())
setwd("C:/Users/DanielGschwentner/Documents/GitHub/WoodStoich24_lake_models")
###############################################################################
# Setup
# load Corman data (needs to be run first!
source("clean_corman.R")
# to df for data input
in.grid <- as.data.frame(corman2)
#load packages
pck <- c("deSolve", "tidyverse", "cowplot", "ggthemes","ggpubr")
lapply(pck, require, character.only = T)
theme_set(theme_pubr() + theme(legend.position = "bottom"))
# Load algae parameters
source("algae_param_vctrs.R")
# Load models
# static model with fixed stoichiometry
source("models/static_liebig_zmix.R") # model 1 in Carly's framework
# Droop model
source("models/dynamic_liebig_zmix.R")
# set timesteps
times <- 1:2000 # for troubleshooting, initial runs
################################################################################
### base predictions w. median values
# static model
(start <- Sys.time())
corman.static <-  lapply(list(static.algae, static.diatoms, static.greens, static.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"])
run <- ode(y, times, parms = params, func = static.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.static.average <- as_data_frame(do.call(rbind, corman.static[[1]]))
corman.static.diatoms <- as_data_frame(do.call(rbind, corman.static[[2]]))
corman.static.greens <- as_data_frame(do.call(rbind, corman.static[[3]]))
corman.static.cyanos <- as_data_frame(do.call(rbind, corman.static[[4]]))
# create summary data frame
static.out <- corman2
static.out$average <- corman.static.average$GPP
static.out$diatoms <- corman.static.diatoms$GPP
static.out$greens <- corman.static.greens$GPP
static.out$cyanos <- corman.static.cyanos$GPP
static.out$model <- "static"
# dynamic model
(start <- Sys.time())
corman.dynamic <-  lapply(list(dynamic.algae, dynamic.diatoms, dynamic.greens, dynamic.cyanos), function(x) {
params <- x
lapply(1:nrow(in.grid), function(i) {
params["Pin"] = in.grid[i, "TP_in"]
params["Nin"] = in.grid[i, "TN_in"]
params["DOC"] = in.grid[i, "DOC_mgL"]
params["z"] = in.grid[i, "z"]
params["SA"] = in.grid[i, "SA"]
params["HRT"] = in.grid[i, "HRT"]
y <- c("A1" = 100, "P" =in.grid[i, "TP_in"], "N" = in.grid[i, "TN_in"],
"QP1" = 0.015, "QN1" = 0.1)
run <- ode(y, times, parms = params, func = dynamic.stoich.zmix)
return(run[max(times),])
})
})
(end <- Sys.time())
time.elapsed <- (end - start)/60/60
print(paste0("Time elapsed = ", time.elapsed, " hours!"))
# extract from list and convert to data-frame
corman.dynamic.average <- as_data_frame(do.call(rbind, corman.dynamic[[1]]))
corman.dynamic.diatoms <- as_data_frame(do.call(rbind, corman.dynamic[[2]]))
corman.dynamic.greens <- as_data_frame(do.call(rbind, corman.dynamic[[3]]))
corman.dynamic.cyanos <- as_data_frame(do.call(rbind, corman.dynamic[[4]]))
# create summary data frame
dynamic.out <- corman2
dynamic.out$average <- corman.dynamic.average$GPP
dynamic.out$diatoms <- corman.dynamic.diatoms$GPP
dynamic.out$greens <- corman.dynamic.greens$GPP
dynamic.out$cyanos <- corman.dynamic.cyanos$GPP
dynamic.out$model <- "dynamic"
# merge and unit conversions, GPP standardization
base.predictions.corman <- bind_rows(static.out, dynamic.out)
base.predictions.corman$model <- factor(base.predictions.corman$model, levels = c("static", "dynamic"))
# wide to long
base.predictions.corman <- base.predictions.corman %>%
gather("species", "est_GPP", -Lake, -c(1:16), -model) %>%
mutate(species = factor(species, levels = c("average", "diatoms", "greens", "cyanos"))) %>%
group_by(model, Lake) %>%
mutate(zscore_gpp = (est_GPP - mean(est_GPP))/sd(est_GPP)) %>%
ungroup()
(obs.plt <- corman2 %>%
ggplot(aes((TN_in/14.007)/(TP_in/30.974), GPP, col = TP_in/30.974)) +
geom_point(size = 2) +
scale_x_log10() +  #scale_y_log10() +
scale_color_viridis_c() +
labs(x = expression("Load TP umoles L"^-1),
y = expression("GPP (mg C L"^-1 ~ " day"^-1~")"),
col = "Load N:P (molar)"))
(mod.plt <- base.predictions.corman %>%
ggplot(aes((TN_in/14.007)/(TP_in/30.974), zscore_gpp,col = TP_in/30.974 )) +
geom_point(size = 2) +
ggh4x::facet_grid2(model~species, scales = "free", independent = "y") +
scale_x_log10() +  #scale_y_log10() +
scale_color_viridis_c() +
labs(x = expression("Load TP umoles L"^-1),
y = expression("z-score GPP Uunitless)"),
col = "Load N:P (molar)") +
guides(shape = "none"))
