---
title: "Corman et al Grid Search"
author: "Daniel Gschwentner"
date: "2024-07-22"
output: html_document
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F, message = F, warning = F)
```

## Notes

-   Need to double check model units, currently in mg Cm^-2^ I believe; need to multiply with lake depth to obtain mg C m^-3\
    **Check\ this\ with\ CO!**^

-   Models produce very poor output when compared to median GPP from Corman et al data set; Carly, I don't think that this approach is very fruitful

## Introduction

Code to conduct parameter value grid search for lake ecosystem models. Models are fit to [Corman et al 2023](https://aslopubs.onlinelibrary.wiley.com/doi/full/10.1002/lno.12449) GPP data across measured TN and TP a range of parameter values. The fit of the model and its parameters is determined by calculating the root-mean-square error (RMSE) between the model estimate and the known parameter values

$$
RMSE = \sqrt{(X_{known} - X_{measured})^2}
$$

Basically, the parameter set which minimizes the RMSE is selected as the "optimal" parameter set and the model(s) are re-fit. Then the model output is compared to the real world data.

## Setup

```{r setup environment and load traits, include=F, warning=F, message=F}
pck <- c("deSolve", "tidyverse", "cowplot", "ggsci", "ggpubr", "ggtern", "patchwork")
lapply(pck, require, character.only = T)
theme_set(theme_cowplot() + 
            theme(legend.justification = "center",
                  legend.position = "bottom", 
                  legend.text = element_text(),
                  legend.title = element_text()))
# load ODE models 
# saved in external files for convenience
# Michalis-Menten model
source("models/mich_single_noLight.R") # michaelis menten kinetics, one algae species; model 1 in Carly's framework
# Droop model
source("models/droop_single_noLight.R") # droop model, one algae species; model 3 in Carly's framework

# set up scenarios
times <- 1:500

# load data set
corman <- read_csv("data4input/Corman2023 metabolism result.csv")

```

### Unit conversions

-   Loads from Corman et al 2023 are in ug m^-3^. Loads are divided by 1000 $\frac{ug}{mg}$ to convert to mg m^-3^ which are required for the model.

-   GPP in Corman et al 2023 are presented in mg O~2~ L^-1^ day^-1^. The models produce output of mg C L^-1^. GPP from Corman et al GPP data are transformed to mg C L^-1^ day^-1^ using the ratio of moles C to moles O~2~ of $\frac{12 mg C}{12 mg O2}$ = 0.375.

```{r edit corman et al data set to get correct units}
# load data
corman2 <- corman
# select columns needed
corman2 <- corman2 %>%
  select(Lake, DateTime, GPP, TN_load, TP_load) %>%
  drop_na() %>%
  mutate(GPP = GPP * 0.375, # convert from O2 to C: 12 mg per mole C/32 mg per mole O2
         TN_load = TN_load/1000, 
         TP_load = TP_load/1000) %>% # divide by 10^3 bc. Corman et al data is in units ug m^-3 and we need mg m^-3
  group_by(Lake) %>%
  summarize(GPP = median(GPP), 
            TN_load = median(TN_load),
            TP_load = median(TP_load))
```

### Create grid of parameter values

Ranges:

-   $K_P$ = 1 to 20 ug L^-1^

-   $K_N$ = 10 to 50 ug L^-1^

-   $V_{maxP}$ = 0.1 to 1 mg P (mg C)^-1^

-   $V_{maxN}$ = 0.1 to 1 mg N (mg C)^-1^

-   $Q_{minP}$ = 0.01 to 0.5 mg P (mg C)^-1^

-   $Q_{minN}$ 0.01 to 0.5 mg N (mg C)^-1^

```{r parameter grids}
# michaelis menten grid
grid <- expand.grid(
  KP1 = seq(1, 20, 1),
  KN1 = seq(10, 50, 5), 
  minQN1 = seq(0.1, 1, 0.1),
  minQP1 = seq(0.1, 1, 0.1) #,
  # upP1 = seq(0.01, 0.05, 0.05),
  # upN1 = seq(0.01, 0.05, 0.05)
)

# repeat grid nrow(corman2) times
grid.new <- grid %>% 
  slice(rep(1:n(), each = nrow(corman2)))

# add in corman2 data
grid.new$Lake <- rep(corman2$Lake, nrow(grid))
grid.new$GPP <- rep(corman2$GPP, nrow(grid))
grid.new$TN_load <- rep(corman2$TN_load, nrow(grid))
grid.new$TP_load <- rep(corman2$TP_load, nrow(grid))

# droop grid
grid.droop <- expand.grid(
  KP1 = seq(1, 20, 1),
  KN1 = seq(10, 50, 5), 
  minQN1 = seq(0.1, 1, 0.1),
  minQP1 = seq(0.1, 1, 0.1),
  upP1 = seq(0.01, 0.05, 0.05),
  upN1 = seq(0.01, 0.05, 0.05)
)

# repeat grid nrow(corman2) times
grid.droop.new <- grid.droop %>% 
  slice(rep(1:n(), each = nrow(corman2)))

# add in corman2 data
grid.droop.new$Lake <- rep(corman2$Lake, nrow(grid.droop))
grid.droop.new$GPP <- rep(corman2$GPP, nrow(grid.droop))
grid.droop.new$TN_load <- rep(corman2$TN_load, nrow(grid.droop))
grid.droop.new$TP_load <- rep(corman2$TP_load, nrow(grid.droop))

```

```{r set up phytoplankton traits, include=F, message=F, warning=F}
### averages

## michaelis-menten model for mean phytoplankton traits
params.mich <- c(
  # lake parameters
  SA= 1,		# lake surface area in km2
  zmix = 2, # lake mixing depth in m
  Pin = NA, # P inflow concentration in mg P m^-3
  Nin = NA, # N inflow concentration in mg N m^-3
  
  #light parameters
  I0 = 400, # incident light
  kBg= 0.1,		# background light attenuation (m-1)/(g C m-3); 0.1-5.6 from Jager & Diehl
  kA=0.0003, # algal light attenuation (m-1)/(mg C m-3); 0.0003 from Jager & Diehl

  # algae physiology parameters
  umax1 = 0.665,
  lA=0.1,			# mortality rate day-1
  v=0.1,			# m d-1; sinking loss of algae
  KLight = 166.53, # light half sat constant 
  KP1 = NA, # phosphorus half sat constant in mg P m^-3 f
  QP1 = NA, # algae cell P quota in mg P mg^-1 C^-1
  KN1 = NA, # nitrogen half sat constant in mg N m^-3 
  QN1 = NA # algae cell N quota in mg N mg^-1 C^-1 
)
names(params.mich) <- c("SA", "zmix", "Pin", "Nin", "I0", 
                        "kBg", "kA", "umax1", "lA", "v", 
                        "KLight", "KP1",  "QP1", "KN1",  "QN1")
names(params.mich)
params.mich <- unlist(params.mich)

## droop model for mean phytoplankton traits

params.droop <- c(
  # lake parameters
  SA= 1,		# lake surface area in km2
  zmix = 2, # lake mixing depth in m
  Pin = NA, # P inflow concentration in mg P m^-3
  Nin = NA, # N inflow concentration in mg N m^-3

  # light parameters
  I0 = 400, # surface light
  kBg= 0.1,		# background light attenuation (m-1)/(g C m-3); 0.1-5.6 from Jager & Diehl
  kA=0.0003, # algal light attenuation (m-1)/(mg C m-3); 0.0003 from Jager & Diehl
 
  # algae physiology parameters
  umax1 = 0.665,
  lA=0.1,			# mortality rate day-1
  v= 0.1,			# m d-1; sinking loss of algae
  KLight = 155.53, # light half sat constant 
  KP1 = NA, # phosphorus half sat constant in mg P m^-3 f
  minQP1 = NA, # algae cell P quota in mg P mg^-1 C^-1 f
  upP1 = NA, # max uptake rate P per day in mg P mg C^-1 day^-1 
  KN1 = NA, # nitrogen half sat constant in mg N m^-3 
  minQN1 = NA, # algae cell N quota in mg N mg^-1 C^-1 f
  upN1 = NA # max uptake rate N per day in mg N mg C^-1 day^-1 
)



names(params.droop) <- c("SA", "zmix", "Pin", "Nin", "I0", "kBg", "kA",
                             "umax1", "lA", "v", "KLight", 
                             "KP1", "minQP1", "upP1", "KN1",
                             "minQN1", "upN1")
names(params.droop)
params.droop <- unlist(params.droop)

```

## Run models

### Michaelis-Menten model

Run the MM model across all grid values and return output; combine estimated GPP with known GPP and calculate RMSE.

```{r run MM across input grid}
# takes over an hour to run!!
# mm.grid <- lapply(1:nrow(grid.new), function(i){
#   # indexing
#   params.mich["KP1"] = grid.new[i, "KP1"]
#   params.mich["KN1"] = grid.new[i, "KN1"]
#   params.mich["QP1"] = grid.new[i, "minQP1"]
#   params.mich["QN1"] = grid.new[i, "minQN1"]
#   params.mich["Pin"] = grid.new[i, "TP_load"]
#   params.mich["Nin"] = grid.new[i, "TN_load"]
#   # starting values
#   y <- c("A1" = 100, "P" = grid.new[i, "TP_load"], "N" = grid.new[i, "TN_load"])
#   run <- ode(y, times, parms = params.mich, func = mich.single)
#   return(run[max(times),])
# })
# # convert to df
# mm.grid <- do.call(rbind, mm.grid)
# mm.grid <- as_data_frame(mm.grid)

# # grids take too long to run, gonna save to r data file and reload for convenience
# save(mm.grid,file = "temporary_model_files/corman2023_MM_gridsearch.Rdata")
load("temporary_model_files/corman2023_MM_gridsearch.Rdata")
# add to grid
grid.new$est_GPP <- mm.grid$A1
 
```

Find best parameters based on RMSE

```{r calculate RMSE for MM}

# add ID label to group
grid.new$group.ID <- rep(1:nrow(grid), each= nrow(corman2))

# calculate RMSE
grid.new.rmse <- grid.new %>%
  group_by(group.ID, KP1, KN1, minQN1, minQP1) %>%
  summarise(RMSE = sqrt((mean(GPP) - mean(est_GPP))^2))
# check distribution of RMSE
hist(grid.new.rmse$RMSE)
which.min(grid.new.rmse$RMSE)
# select best parameters
best.parm <- grid.new.rmse[which.min(grid.new.rmse$RMSE), ]
```

RMSE increases with P-parameters but is largely independent of N-parameters. You can see in the plot below that increasing $K_P$ and $minQ_P$ increases the RMSE. In contrast, increasing $K_N$ and $minQ_N$ does not seem to influence RMSE.

```{r plot RMSE and P for MM, echo = T, dpi = 500}

Kp.rmse <- grid.new.rmse %>%
  ggplot(aes(KP1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("K"["P"] ~ " ug L"^-1), y = "RMSE")

Kn.rmse <- grid.new.rmse %>%
  ggplot(aes(KN1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("K"["N"] ~ " ug L"^-1), y = NULL)

QP.rmse <- grid.new.rmse %>%
  ggplot(aes(minQP1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("minQ"["P"] ~ "in mg P (mg C)"^-1), y = NULL)

QN.rmse <- grid.new.rmse %>%
  ggplot(aes(minQN1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("minQ"["N"] ~ "in mg N (mg C)"^-1), y = NULL)

Kp.rmse + Kn.rmse + QP.rmse + QN.rmse + plot_layout(ncol = 4)

```

Re-run model with best parameters

```{r re-run MM model with the best parameters}
best.run <- lapply(1:nrow(corman2), function(i){
  # indexing
  params.mich["KP1"] = pull(best.parm[1, "KP1"])
  params.mich["KN1"] = pull(best.parm[1, "KN1"])
  params.mich["QP1"] = pull(best.parm[1, "minQP1"])
  params.mich["QN1"] = pull(best.parm[1, "minQN1"])
  params.mich["Pin"] = pull(corman2[i, "TP_load"])
  params.mich["Nin"] = pull(corman2[i, "TN_load"])
  # starting values
  y <- c("A1" = 100, "P" = corman2[i, "TP_load"], "N" = corman2[i, "TN_load"])
  run <- ode(y, times, parms = params.mich, func = mich.single)
  return(run[max(times),])
})
# convert to df
best.run <- do.call(rbind, best.run)
best.run <- as_data_frame(best.run)
# combine with original df
best.run <- bind_cols(best.run, corman2)
```

Plot comparison of RMSE between Corman et al 2023 data set and the output from the Michaelis-Menten model.

```{r compare output of best model and real world data, ech = F, dpi = 500}

best.run.plt <- best.run %>%
  mutate(TN_TP_load = (TN_load/14.007)/(TP_load/30.974)) %>%
  ggplot() + 
  geom_point(aes(GPP, A1, col = TN_TP_load), size = 2.5) + 
  geom_abline(slope = 1, intercept = 0, lty = "dashed") + 
  labs(x = expression("Measured GPP mg C L"^-1), 
       y = expression("Modelled GPP mg C m"^-1), 
       col = "Load TN:TP molar") + 
  scale_color_viridis_b(option = "C")

best.run.plt

```

### Droop model

Run the MM model across all grid values and return output; combine estimated GPP with known GPP and calculate RMSE.

```{r run droop model across inflow loads and parameter values}

#takes over an hour to run!!
# droop.grid <- lapply(1:nrow(grid.droop.new), function(i){
#   # indexing
#   params.droop["KP1"] = grid.droop.new[i, "KP1"]
#   params.droop["KN1"] = grid.droop.new[i, "KN1"]
#   params.droop["minQP1"] = grid.droop.new[i, "minQP1"]
#   params.droop["minQN1"] = grid.droop.new[i, "minQN1"]
#   params.droop["upP1"] = grid.droop.new[i, "upP1"]
#   params.droop["upN1"] = grid.droop.new[i, "upN1"]
#   params.droop["Pin"] = grid.droop.new[i, "TP_load"]
#   params.droop["Nin"] = grid.droop.new[i, "TN_load"]
#   # starting values
#   y <- c("A1" = 100, "P" = grid.droop.new[i, "TP_load"],
#          "N" = grid.droop.new[i, "TN_load"],
#          "QP1" = 0.015,
#          "QN1" = 0.1)
#   run <- ode(y, times, parms = params.droop, func = droop.single)
#   return(run[max(times),])
# })
# # convert to df
# droop.grid <- do.call(rbind, droop.grid)
# droop.grid <- as_data_frame(droop.grid)
# 
# # grids take too long to run, gonna save to r data file and reload for convenience
# save(droop.grid,file = "temporary_model_files/corman2023_droop_gridsearch.Rdata")
load("temporary_model_files/corman2023_droop_gridsearch.Rdata")

# add to grid
grid.droop.new$est_GPP <- droop.grid$A1


```

Calculate RMSE and find best parameters

```{r calculate RMSE and find best parameters for droop model}
# add ID label to group
grid.droop.new$group.ID <- rep(1:nrow(grid.droop), each= nrow(corman2))

# calculate RMSE
grid.droop.new.rmse <- grid.droop.new %>%
  group_by(group.ID, KP1, KN1, minQN1, minQP1, upP1, upN1) %>%
  summarise(RMSE = sqrt((mean(GPP) - mean(est_GPP))^2))
# check distribution of RMSE
hist(grid.droop.new.rmse$RMSE)
which.min(grid.droop.new.rmse$RMSE)
# select best parameters
best.parm.droop <- grid.droop.new.rmse[which.min(grid.droop.new.rmse$RMSE), ]
```

Lorem ipsum here 

```{r plot RMSE and P for droop, echo = T, dpi = 500}

Kp.droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(KP1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("K"["P"] ~ " ug L"^-1), y = "RMSE")

Kn..droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(KN1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("K"["N"] ~ " ug L"^-1), y = NULL)

QP.droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(minQP1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("minQ"["P"] ~ "in mg P (mg C)"^-1), y = NULL)

QN.droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(minQN1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("minQ"["N"] ~ "in mg N (mg C)"^-1), y = NULL)

uP.droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(upP1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("uptake P mg P (mg C)"^-1), y = NULL)

uN.droop.rmse <- grid.droop.new.rmse %>%
  ggplot(aes(upN1, RMSE)) + geom_point(alpha = 0.3) + 
  labs(x = expression("uptake N mg P (mg C)"^-1), y = NULL)

Kp.rmse + Kn.rmse + QP.rmse + QN.rmse + uP.droop.rmse + uN.droop.rmse + 
  plot_layout(ncol = 6)

```


Re-run model with best parameters

```{r re-run droop  model with the best parameters}
best.run.droop <- lapply(1:nrow(corman2), function(i){
  # indexing
    params.droop["KP1"] = pull(best.parm.droop[1, "KP1"])
  params.droop["KN1"] = pull(best.parm.droop[1, "KN1"])
  params.droop["minQP1"] = pull(best.parm.droop[1, "minQP1"])
  params.droop["minQN1"] = pull(best.parm.droop[1, "minQN1"])
  params.droop["upP1"] = pull(best.parm.droop[1, "upP1"])
  params.droop["upN1"] = pull(best.parm.droop[1, "upN1"])
  params.droop["Pin"] = pull(corman2[i, "TP_load"])
  params.droop["Nin"] = pull(corman2[i, "TP_load"])
  # starting values
  y <- c("A1" = 100, "P" = corman2[i, "TP_load"], "N" = corman2[i, "TN_load"],
          "QP1" = 0.015,"QN1" = 0.1)
  run <- ode(y, times, parms = params.droop, func = droop.single)
  return(run[max(times),])
})
# convert to df
best.run.droop <- do.call(rbind, best.run.droop)
best.run.droop <- as_data_frame(best.run.droop)
# combine with original df
best.run.droop <- bind_cols(best.run.droop, corman2)
```

Plot comparison of RMSE between Corman et al 2023 data set and the output from the Droop model.

```{r compare output of best model and real world data, ech = F, dpi = 500}

best.run.droop.plt <- best.run.droop %>%
  mutate(TN_TP_load = (TN_load/14.007)/(TP_load/30.974)) %>%
  ggplot() + 
  geom_point(aes(GPP, A1, col = TN_TP_load), size = 2.5) + 
  geom_abline(slope = 1, intercept = 0, lty = "dashed") + 
  labs(x = expression("Measured GPP mg C L"^-1), 
       y = expression("Modelled GPP mg C m"^-1), 
       col = "Load TN:TP molar") + 
  scale_color_viridis_b(option = "C")

best.run.droop.plt

```